Great news\! Your codebase is 90% of the way to achieving all your goals. You have already completed the most difficult part: **creating a custom Android native module (`CallLogModule.java`) to read call logs and contacts**.

Your module is correctly registered in `MainApplication.kt`, and your `AndroidManifest.xml` already includes the necessary permissions for reading call logs and contacts.

Here is the full instruction set to connect the final pieces.

-----

## Part 1: Enable Full Contact Read/Write Sync (Device & Server)

Your app currently *reads* contacts from the device (using your `CallLogModule`) but only *writes* contacts to your Supabase server. Hereâ€™s how to make it write to **both** the device and the server.

### Step 1: Install `expo-contacts`

This package will handle writing contacts to the device.

```bash
npm install expo-contacts
```

### Step 2: Add `WRITE_CONTACTS` Permission

Open `android/app/src/main/AndroidManifest.xml` and add the `WRITE_CONTACTS` permission.

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
  <uses-permission android:name="android.permission.INTERNET"/>
  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
  <uses-permission android:name="android.permission.READ_PHONE_STATE"/>
  <uses-permission android:name="android.permission.READ_CALL_LOG"/>
  <uses-permission android:name="android.permission.READ_CONTACTS"/>
  <uses-permission android:name="android.permission.WRITE_CONTACTS"/>
  <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
  ...
</manifest>
```

### Step 3: Modify `services/contactService.ts`

Update your `ContactService` to use `expo-contacts` to write to the device *after* successfully writing to Supabase.

```typescript
// services/contactService.ts
import { supabase } from './supabaseClient';
import { Contact, Call, UserProfile } from '../constants/types';
import { normalizeIranianPhoneNumber, arePhoneNumbersEqual } from './phoneNumberUtils';
import * as Contacts from 'expo-contacts'; // <-- Import expo-contacts

export class ContactService {
  
  // ... (fetchContacts remains the same)

  static async createContact(
    name: string, 
    phoneNumber: string, 
    userId: string
  ): Promise<{ success: boolean; error?: string; data?: Contact }> {
    // ... (your existing normalization and duplicate check logic)

    // Check for existing contact with same normalized number across all users
    const { data: existingContacts } = await supabase
      .from('contacts')
      .select('*')
      .eq('phone_number', normalizedPhone.normalized);

    // ... (your existing logic for handling existing contacts)

    // 1. Create in Supabase
    const { data, error } = await supabase
      .from('contacts')
      .insert({
        name: name.trim(),
        phone_number: normalizedPhone.normalized,
        created_by_user_id: userId
      })
      .select()
      .single();

    if (error) {
      return { success: false, error: error.message };
    }

    // 2. Create on Device
    try {
      const contact = {
        [Contacts.Fields.FirstName]: name.trim(),
        phoneNumbers: [{
          label: 'mobile',
          number: normalizedPhone.normalized,
        }],
      };
      await Contacts.addContactAsync(contact);
    } catch (deviceError: any) {
      console.warn('Failed to add contact to device, but saved to server:', deviceError.message);
      // Don't return an error, as the server-side was successful
    }

    return { success: true, data };
  }

  static async updateContact(
    contactId: string,
    name: string,
    phoneNumber: string,
    userId: string // <-- Ensure userId is passed in
  ): Promise<{ success: boolean; error?: string; data?: Contact }> {
    
    // ... (your existing permission checks and normalization)

    // 1. Update in Supabase
    const { data, error } = await supabase
      .from('contacts')
      .update({
        name: name.trim(),
        phone_number: normalizedPhone.normalized,
        updated_at: new Date().toISOString()
      })
      .eq('id', contactId)
      .select()
      .single();

    if (error) {
      return { success: false, error: error.message };
    }

    // 2. Update on Device
    try {
      // Find the device contact to update (this is tricky, as we don't store the device contact ID)
      // We'll search by phone number. This is imperfect but the best we can do.
      const { data: deviceContacts } = await Contacts.getContactsAsync({
        fields: [Contacts.Fields.PhoneNumbers],
        phoneNumbers: [normalizedPhone.normalized],
      });

      if (deviceContacts.length > 0) {
        const deviceContact = deviceContacts[0];
        deviceContact.firstName = name.trim();
        // You may need more logic here to find and update the *correct* phone number
        // For this example, we assume it's the first one.
        if (deviceContact.phoneNumbers && deviceContact.phoneNumbers.length > 0) {
          deviceContact.phoneNumbers[0].number = normalizedPhone.normalized;
        }
        await Contacts.updateContactAsync(deviceContact);
      }
    } catch (deviceError: any) {
      console.warn('Failed to update contact on device, but saved to server:', deviceError.message);
    }

    return { success: true, data };
  }

  static async deleteContact(contactId: string, userId: string): Promise<{ success: boolean; error?: string }> {
    
    // ... (your existing permission checks)
    const { data: contactToDelete } = await supabase
      .from('contacts')
      .select('id, phone_number') // Get phone number before deleting
      .eq('id', contactId)
      .single();
    
    if (!contactToDelete) {
         return { success: false, error: 'Contact not found' };
    }
    
    // 1. Delete from Supabase
    const { error } = await supabase
      .from('contacts')
      .delete()
      .eq('id', contactId);

    if (error) {
      return { success: false, error: error.message };
    }

    // 2. Delete from Device
    try {
      const { data: deviceContacts } = await Contacts.getContactsAsync({
        fields: [Contacts.Fields.PhoneNumbers],
        phoneNumbers: [contactToDelete.phone_number],
      });

      if (deviceContacts.length > 0) {
        await Contacts.removeContactAsync(deviceContacts[0].id);
      }
    } catch (deviceError: any) {
       console.warn('Failed to delete contact from device, but removed from server:', deviceError.message);
    }

    return { success: true };
  }
  
  // ... (all other methods remain the same)
}
```

-----

## Part 2: Enable Call Log Sync (Read from Device & Send to Server)

This is already implemented in your `services/androidCallLogService.ts` and `services/backgroundSync.ts`. The function `BackgroundSyncService.syncAllDeviceData` does *exactly* what you need.

You just need to ask for permissions and provide a way to trigger it.

### Step 1: Request Permissions on App Load

In `app/(tabs)/team.tsx` (or any other component that loads early), add a `useEffect` to request the new permissions.

```typescript
// app/(tabs)/team.tsx
import React, { useState, useEffect } from 'react';
// ... other imports
import { AndroidCallLogService } from '../../services/androidCallLogService';
import { Platform } from 'react-native';

export default function TeamScreen() {
  // ... your existing state
  
  useEffect(() => {
    // Refresh user profile to get latest role
    refreshProfile();
    loadTeamMembers();
    
    // Request permissions when this screen loads
    if (Platform.OS === 'android') {
      AndroidCallLogService.requestPermissions().then(granted => {
        if (granted) {
          console.log('All permissions granted');
        } else {
          console.warn('Some permissions were denied');
        }
      });
    }
  }, []);

  // ... rest of your component
}
```

### Step 2: Add a "Sync Now" Button (for Testing)

You can add a "Sync Now" button to your `app/(tabs)/team.tsx` file to test the sync. Your `backgroundSync.ts` file already has the perfect function for this: `syncAllDeviceData`.

```typescript
// app/(tabs)/team.tsx

// ...
import { BackgroundSyncService } from '../../services/backgroundSync';
// ...

export default function TeamScreen() {
  // ...
  const [isSyncing, setIsSyncing] = useState(false);
  // ...

  const handleManualSync = async () => {
    if (!userProfile) return;
    setIsSyncing(true);
    
    const result = await BackgroundSyncService.syncAllDeviceData(userProfile.id);
    
    setIsSyncing(false);
    
    if (result.success) {
      showAlert('Sync Complete', `Synced ${result.contacts.added} new contacts and ${result.calls.synced} new calls.`);
      // Refresh the context data
      loadTeamMembers(); // You might want to refresh contacts/calls context here too
    } else {
      showAlert('Sync Failed', result.errors.join('\n'));
    }
  };

  // ...

  return (
    <View style={[styles.container, { paddingTop: insets.top }]}>
      {/* Header */}
      <View style={styles.header}>
        {/* ... your existing header ... */}
        <View style={styles.headerActions}>
          {/* ... your add member button ... */}

          {/* ADD THIS SYNC BUTTON */}
          <TouchableOpacity 
            style={styles.refreshButton} 
            onPress={handleManualSync} 
            disabled={isSyncing}
          >
            <MaterialIcons 
              name={isSyncing ? "sync" : "sync-disabled"} 
              size={24} 
              color={isSyncing ? "#8E8E93" : "#007AFF"} 
            />
          </TouchableOpacity>
          
          <TouchableOpacity style={styles.refreshButton} onPress={loadTeamMembers}>
            <MaterialIcons name="refresh" size={24} color="#007AFF" />
          </TouchableOpacity>
          
          {/* ... your logout button ... */}
        </View>
      </View>
      {/* ... rest of your component ... */}
    </View>
  );
}
```

-----

## Part 3: Enable Background Sync (Your "Workaround")

Your request for a "workaround" is best implemented with `expo-background-fetch`, which you have already installed and set up in `services/backgroundSync.ts`. This will periodically sync data, even if the app is closed.

You are just missing two small pieces:

1.  Saving the `userId` to `AsyncStorage` so the headless task can access it.
2.  Implementing the `DEVICE_SYNC_TASK` to use that `userId` and run the sync.

### Step 1: Save User ID in `contexts/AuthContext.tsx`

The background task runs without React context, so it needs to get the `userId` from persistent storage.

```typescript
// contexts/AuthContext.tsx
import React, { createContext, useEffect, useState, ReactNode } from 'react';
import { supabase } from '../services/supabaseClient';
import { AuthContextType, UserProfile } from '../constants/types';
import AsyncStorage from '@react-native-async-storage/async-storage'; // <-- Import

export const AuthContext = createContext<AuthContextType | undefined>(undefined);
const USER_ID_KEY = 'auth-user-id'; // <-- Add key

export function AuthProvider({ children }: { children: ReactNode }) {
  // ... your existing state

  // ... (fetchUserData, refreshProfile, signIn, signOut)

  useEffect(() => {
    // ... (getSession remains the same)

    // Listen for auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        console.log('Auth state change:', event, session?.user?.id);
        setSession(session);
        setUser(session?.user ?? null);
        
        if (session?.user) {
          await fetchUserData(session.user.id);
          // <-- ADD THIS: Save user ID to storage
          await AsyncStorage.setItem(USER_ID_KEY, session.user.id);
        } else {
          setUserProfile(null);
          // <-- ADD THIS: Remove user ID from storage
          await AsyncStorage.removeItem(USER_ID_KEY);
        }
        setLoading(false);
      }
    );

    return () => subscription.unsubscribe();
  }, []);

  // ... (value and provider return)
}
```

### Step 2: Implement the Headless Task in `services/backgroundSync.ts`

Now, update the `DEVICE_SYNC_TASK` to use the stored `userId`.

```typescript
// services/backgroundSync.ts
import * as BackgroundFetch from 'expo-background-fetch';
import * as TaskManager from 'expo-task-manager';
import { ContactService } from './contactService';
import { AndroidCallLogService } from './androidCallLogService';
import { Platform } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage'; // <-- Import

const BACKGROUND_SYNC_TASK = 'background-contacts-sync';
const DEVICE_SYNC_TASK = 'device-data-sync';
const USER_ID_KEY = 'auth-user-id'; // <-- Add key

// ... (BACKGROUND_SYNC_TASK remains the same)

// Define the background task for device sync
TaskManager.defineTask(DEVICE_SYNC_TASK, async () => {
  try {
    console.log('Background device sync task started');
    
    // 1. Get user ID from storage
    const userId = await AsyncStorage.getItem(USER_ID_KEY);
    
    if (!userId) {
      console.log('Background device sync: No user ID found, skipping.');
      return BackgroundFetch.BackgroundFetchResult.NoData;
    }

    console.log(`Background device sync: Running for user ${userId}`);
    
    // 2. Run the sync function
    const result = await BackgroundSyncService.syncAllDeviceData(userId);

    if (result.success) {
      console.log('Background device sync completed successfully.');
      return BackgroundFetch.BackgroundFetchResult.NewData;
    } else {
      console.error('Background device sync failed:', result.errors);
      return BackgroundFetch.BackgroundFetchResult.Failed;
    }

  } catch (error) {
    console.error('Background device sync error:', error);
    return BackgroundFetch.BackgroundFetchResult.Failed;
  }
});

export class BackgroundSyncService {
  // ...
  // ... (registerBackgroundSync remains the same)
  // ...

  /**
   * Register device data sync (call logs and contacts)
   */
  static async registerDeviceDataSync() {
    // Only register for Android
    if (Platform.OS !== 'android') return { success: false, error: 'Not on Android' };
    
    try {
      const status = await BackgroundFetch.getStatusAsync();
      
      if (status === BackgroundFetch.BackgroundFetchStatus.Available) {
        await BackgroundFetch.registerTaskAsync(DEVICE_SYNC_TASK, {
          minimumInterval: 15 * 60, // 15 minutes
          stopOnTerminate: false,
          startOnBoot: true, // <-- Needs RECEIVE_BOOT_COMPLETED permission (which you have)
        });
        
        console.log('Background device data sync registered successfully');
        return { success: true };
      } else {
        console.log('Background fetch not available for device sync:', status);
        return { 
          success: false, 
          error: 'Background sync not available on this device' 
        };
      }
    } catch (error) {
      console.error('Error registering device data sync:', error);
      return { success: false, error: String(error) };
    }
  }

  // ... (rest of the file remains the same)
}
```

### Step 3: Register the Task in `contexts/ContactContext.tsx`

Finally, make sure the `DEVICE_SYNC_TASK` is registered when the app loads.

```typescript
// contexts/ContactContext.tsx
// ... (imports)

export function ContactProvider({ children }: { children: ReactNode }) {
  // ... (state)

  // ... (loadData, refreshContacts, etc.)

  useEffect(() => {
    if (userProfile?.id) {
      loadData();

      // Register background sync
      BackgroundSyncService.registerBackgroundSync().then(result => {
        if (result.success) {
          setBackgroundSyncEnabled(true);
          console.log('Background server sync enabled');
        } else {
          console.log('Background server sync not available:', result.error);
        }
      });

      // <-- ADD THIS: Register the device sync task
      BackgroundSyncService.registerDeviceDataSync().then(result => {
        if (result.success) {
          console.log('Background device sync enabled');
        } else {
          console.log('Background device sync not available:', result.error);
        }
      });

      // ... (rest of your useEffect)
    }
  }, [userProfile?.id]);

  // ... (value and provider return)
}
```

With these changes, your app will now:

1.  Read and Write contacts to both the device and your Supabase server.
2.  Read call logs from the device.
3.  Automatically (and periodically) sync device contacts and call logs to your server every 15 minutes, even when the app is in the background or the device has been restarted.